# CLAUDE.md

このファイルは、このリポジトリで作業する Claude Code (claude.ai/code) へのガイダンスを提供します。

**重要**: このプロジェクトでは日本語でやり取りを行います。

## プロジェクト概要

**DDigest** は個人用技術情報ダイジェスト生成ツール - RSS/Atom フィードを取得し、個人の技術スタックに対してスコアリングし、READ NOW / LATER / IGNORE に分類する CLI ツールです。

**中心思想**: このツールは技術ニュースを読むためのものではなく、何を安全に無視できるかを体系的に判断するためのものです。「これを読むべきか？」という判断を機械に委譲し、人間を情報過多から解放します。

## 現在の状態

これは**実装前プロジェクト**です。設計ドキュメントのみが存在します：
- `DRAFT.md`: MVP仕様、CLI設計、データモデル、実装計画
- `CONCEPT.md`: 設計思想、問題設定、アーキテクチャ上の決定
- `README.md`: 空

コードはまだ書かれていません。

## 計画されているアーキテクチャ

### コアコンポーネント
1. **Fetcher**: RSS/Atom フィードをダウンロードし、新規・更新アイテムを検出
2. **Normalizer**: 様々なフィード形式からコンテンツを抽出・標準化
3. **SQLite Store**: content_hash による重複排除を含む永続化ストレージ
4. **Scorer**: ルールベースのスコアリングエンジン（キーワード、パターン、タグ）
5. **Summarizer**: LLM統合（コスト削減のため READ NOW アイテムのみ）
6. **CLI**: 構造化された出力を持つコマンドインターフェース

### データフロー
```
RSS/Atom → Fetcher → Normalizer → SQLite → Scorer → Summarizer (READ NOW のみ) → CLI
```

### データベーススキーマ (SQLite)
- **sources**: タグ付き RSS フィード定義
- **items**: url (unique), content_hash, status, score, reasons, summary を持つ記事
- **item_events**: オプションの監査ログ

### 計画されている CLI コマンド
```bash
ddigest fetch          # フィード取得・新規アイテム検出
ddigest score          # スコアリングと分類
ddigest today          # 今日のダイジェスト表示
ddigest show <id>      # 要約と判定理由を表示
ddigest open <id>      # ブラウザで開く
ddigest mark <id>      # ステータス変更 (ignore/later/done)
ddigest queue          # LATER キュー表示
```

## 主要な設計判断

### なぜルールベース + LLM ハイブリッドなのか？
- **ルール**: 下限を保証（セキュリティ・破壊的変更は必ず検出）
- **LLM**: 自然言語理解と個人化された説明
- 分類はルール駆動、説明は LLM 駆動

### なぜ READ NOW のみ LLM を使うのか？
- コスト最適化 - アクション可能なアイテムのみ要約
- ほとんどのアイテムは IGNORE であり、全件要約は無駄
- ユーザーは緊急アイテムのみ詳細なコンテキストが必要

### なぜ CLI/TUI なのか？
- 日常使用ツールは認知負荷を最小化すべき
- ターミナルは判断に集中でき、視覚的ノイズがない
- 自動化（cron、systemd）との統合が容易

### なぜ SQLite なのか？
- シングルユーザーツール、同時書き込みなし
- ポータブル、サーバー依存なし
- content_hash による信頼性の高い重複排除

## 設定ファイル (ddigest.yaml)

プロジェクトルートまたは `~/.config/ddigest/` に配置。以下を含む：
- LLM プロバイダー設定（OpenAI API キー、モデル、レート制限）
- タグ付き RSS ソース
- スコアリングルール: boost/penalize キーワードとスコア調整
- 閾値: read_now (80+), later (45-79), ignore (<45)

## 実装ガイドライン

### スコアリングシステム
- ベーススコアは 50 から開始（中立）
- キーワードマッチでスコアを上下調整
- セキュリティ/CVE キーワード: +90
- 破壊的変更: +70
- 無関係な技術スタックキーワード: -30
- 最終分類は設定の閾値を使用

### コンテンツ重複排除
- 正規化されたコンテンツの SHA256 ハッシュを生成
- items テーブルに content_hash として保存
- 挿入前にハッシュをチェックして重複を検出
- 更新されたアイテム = 同じ URL、異なる content_hash

### LLM プロンプト設計
出力は以下の JSON 形式：
- `summary`: 2-3 行の要約
- `why_you`: これがユーザーに重要な理由のリスト
- `recommended_action`: wait | update now | investigate | ignore
- `confidence`: 0.0-1.0

### エラーハンドリング
- フェッチ中のネットワーク障害: ログを記録し、他のソースを継続
- LLM API エラー: 要約なしでアイテムを保存、後で再試行
- 無効な RSS: ソース名をログに記録してスキップ

## MVP スコープで構築しないもの

- Web UI なし
- 自動学習/ML 最適化なし
- 全文検索なし
- ソーシャル機能なし
- デバイス間同期なし

## 将来の拡張（MVP 後）

- アセットスキャン: `flake.lock`、`Cargo.lock`、`package.json` を解析して技術スタックを自動検出
- ratatui を使った TUI インターフェース
- Systemd timer / cron 統合
- 高優先度アイテムのデスクトップ通知
- Email/Slack へのエクスポート

## 開発哲学

**「賢くするより、静かにする」**
- 成功 = 通知の減少であり、機能の増加ではない
- IGNORE の信頼性は READ NOW の正確性と同じくらい重要
- 明示的なユーザーフィードバック（ignore/later のマーク）は暗黙的な学習より価値がある
